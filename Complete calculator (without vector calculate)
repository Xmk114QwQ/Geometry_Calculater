import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, colorchooser
import sympy as sp
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
from matplotlib import rcParams
import numpy as np

class GeometryAnalyzer:
    def __init__(self):
        self.points = {}       # {点名: (x, y, z)} 存储数值坐标
        self.segments = {}     # {线段名: (起点, 终点, 颜色, 线型)} 存储线段信息

    def add_point(self, name, x, y, z=0):
        """添加点（自动转换符号表达式为数值）"""
        if name in self.points:
            return False, f"点 '{name}' 已存在"
        
        try:
            # 尝试将坐标转换为数值
            x_val = float(sp.sympify(x).evalf())
            y_val = float(sp.sympify(y).evalf())
            z_val = float(sp.sympify(z).evalf())
        except Exception as e:
            return False, f"坐标解析错误: {str(e)}"
        
        self.points[name] = (x_val, y_val, z_val)
        return True, f"成功添加点 '{name}'"

    def add_segment(self, start, end, color='#0000FF', linestyle='solid'):
        """添加线段（自动验证点存在性）"""
        if start not in self.points or end not in self.points:
            return False, "起点或终点不存在"
        seg_name = f"{start}{end}"
        if seg_name in self.segments:
            return False, f"线段 '{seg_name}' 已存在"
        
        self.segments[seg_name] = (start, end, color, linestyle)
        return True, f"成功添加线段 '{seg_name}'"

    def analyze_relations(self):
        """分析所有线段的几何关系"""
        relations = {
            'perpendicular': [],
            'parallel': [],
            'length_ratio': [],
            'length_equal': [],
            'length_diff': []
        }

        seg_names = list(self.segments.keys())
        for i in range(len(seg_names)):
            seg1 = seg_names[i]
            s1_start, s1_end, color1, linestyle1 = self.segments[seg1]
            p1_start = self.points[s1_start]
            p1_end = self.points[s1_end]
            v1 = (p1_end[0]-p1_start[0], p1_end[1]-p1_start[1], p1_end[2]-p1_start[2])

            for j in range(i+1, len(seg_names)):
                seg2 = seg_names[j]
                s2_start, s2_end, color2, linestyle2 = self.segments[seg2]
                p2_start = self.points[s2_start]
                p2_end = self.points[s2_end]
                v2 = (p2_end[0]-p2_start[0], p2_end[1]-p2_start[1], p2_end[2]-p2_start[2])

                # 垂直判断（点积为0）
                dot = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]
                if abs(dot) < 1e-6:
                    relations['perpendicular'].append((seg1, seg2))

                # 平行判断（叉积为0）
                cross_x = v1[1]*v2[2] - v1[2]*v2[1]
                cross_y = v1[2]*v2[0] - v1[0]*v2[2]
                cross_z = v1[0]*v2[1] - v1[1]*v2[0]
                if abs(cross_x) < 1e-6 and abs(cross_y) < 1e-6 and abs(cross_z) < 1e-6:
                    relations['parallel'].append((seg1, seg2))

                # 长度计算
                len1 = (v1[0]**2 + v1[1]**2 + v1[2]**2)**0.5
                len2 = (v2[0]**2 + v2[1]**2 + v2[2]**2)**0.5

                # 长度比
                if len2 != 0:
                    ratio = round(len1/len2, 2)
                    relations['length_ratio'].append((seg1, seg2, ratio))

                # 长度相等
                if abs(len1 - len2) < 1e-6:
                    relations['length_equal'].append((seg1, seg2))

                # 长度差
                if len1 != len2:
                    diff = round(abs(len1 - len2), 2)
                    relations['length_diff'].append((seg1, seg2, diff))

        return relations

    def get_status(self):
        """获取当前状态信息"""
        point_details = [f"{name}({x:.2f}, {y:.2f}, {z:.2f})" 
                        for name, (x, y, z) in self.points.items()]
        
        segment_details = []
        for seg_name, (start, end, color, linestyle) in self.segments.items():
            s_x, s_y, s_z = self.points[start]
            e_x, e_y, e_z = self.points[end]
            length = ((e_x - s_x)**2 + (e_y - s_y)**2 + (e_z - s_z)**2)**0.5
            segment_details.append(f"{seg_name}({start}-{end}, 长度={length:.2f}, 颜色={color}, 线型={linestyle})")
        
        return {
            'points_count': len(self.points),
            'segments_count': len(self.segments),
            'point_details': point_details,
            'segment_details': segment_details
        }

class GeometryGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("智能几何分析器")
        self.root.geometry("1200x800")
        self.root.configure(bg="#FFFFFF")  # 纯白色背景
        
        # 配置更现代的主题（白色版）
        style = ttk.Style()
        style.theme_use("clam")
        style.configure(".", background="#FFFFFF")
        style.configure("TFrame", background="#FFFFFF")
        style.configure("TButton", background="#4a86e8", foreground="white")
        style.map("TButton", background=[('active', '#3a76d8')])
        style.configure("TLabel", background="#FFFFFF", foreground="black")
        style.configure("TLabelframe", background="#FFFFFF")
        style.configure("TLabelframe.Label", background="#FFFFFF", foreground="black")
        style.configure("TNotebook", background="#FFFFFF")
        style.configure("TNotebook.Tab", background="#f0f0f0", padding=[10, 5], foreground="black")
        style.map("TNotebook.Tab", background=[("selected", "#FFFFFF")])
        style.configure("TCombobox", fieldbackground="white")
        style.configure("Vertical.TScrollbar", background="#e0e0e0")
        
        # 初始化分析器
        self.analyzer = GeometryAnalyzer()
        
        # 创建主框架
        self.main_frame = ttk.Frame(self.root, padding=10)
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # 创建主分割窗口 (PanedWindow) - 可拖动的分隔条
        self.paned_window = ttk.PanedWindow(self.main_frame, orient=tk.HORIZONTAL)
        self.paned_window.pack(fill=tk.BOTH, expand=True)
        
        # 左侧控制面板框架 (可调整大小)
        self.control_container = ttk.Frame(self.paned_window)
        self.paned_window.add(self.control_container, weight=1)  # 初始权重设为1 (约占总宽的25%)
        
        # 设置分割条样式
        style.configure("Sash", background="#d0d0d0", gripcount=5)
        
        # 右侧绘图区域框架
        self.plot_container = ttk.Frame(self.paned_window)
        self.paned_window.add(self.plot_container, weight=3)  # 初始权重设为3 (约占总宽的75%)
        
        # 创建画布和滚动条 (左侧控制面板内)
        self.canvas = tk.Canvas(self.control_container, bg="#FFFFFF", highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self.control_container, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)
        
        # 配置画布滚动
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        # 绑定鼠标滚轮事件
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        
        # 绑定画布大小变化事件
        self.canvas.bind("<Configure>", self._on_canvas_resize)
        
        # 布局画布和滚动条
        self.canvas.pack(side="left", fill="both", expand=True, padx=(0, 2))
        self.scrollbar.pack(side="right", fill="y", padx=(0, 2))
        
        # 控制面板框架
        self.control_frame = ttk.LabelFrame(self.scrollable_frame, text="控制面板", padding=10)
        self.control_frame.pack(fill=tk.X, expand=True)
        
        # 添加3D切换按钮
        self.btn_switch_3d = ttk.Button(self.control_frame, text="切换3D视图", 
                                      command=self.toggle_3d_view)
        self.btn_switch_3d.pack(fill=tk.X, pady=5)
        
        # 初始化线段样式默认值
        self.segment_color = '#0000FF'  # 默认蓝色
        self.segment_linestyle = 'solid'  # 默认实线
        
        # 创建功能选项卡
        self.notebook = ttk.Notebook(self.control_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # 几何操作选项卡
        self.geo_ops_tab = ttk.Frame(self.notebook, padding=10)
        self.notebook.add(self.geo_ops_tab, text="几何操作")
        self._setup_geo_ops_tab()
        
        # 分析选项卡
        self.analysis_tab = ttk.Frame(self.notebook, padding=10)
        self.notebook.add(self.analysis_tab, text="分析结果")
        self._setup_analysis_tab()
        
        # 状态选项卡
        self.status_tab = ttk.Frame(self.notebook, padding=10)
        self.notebook.add(self.status_tab, text="状态信息")
        self._setup_status_tab()
        
        # 右侧绘图区框架
        self.plot_frame = ttk.LabelFrame(self.plot_container, text="几何图形", padding=10)
        self.plot_frame.pack(fill=tk.BOTH, expand=True)
        
        # 创建绘图区域
        self.fig = Figure(figsize=(8, 6), dpi=100, facecolor="white")
        self.canvas_plot = FigureCanvasTkAgg(self.fig, self.plot_frame)
        self.canvas_plot.get_tk_widget().pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.canvas_plot.get_tk_widget().configure(bg="white")
        
        # 初始化2D绘图
        self.ax = self.fig.add_subplot(111)
        self.ax.set_facecolor("white")  # 白色背景
        self.ax.grid(True, linestyle='--', alpha=0.7)
        self.ax.set_title("2D几何视图", color="black")
        self.ax.tick_params(colors='black')
        self.ax.set_aspect('equal')  # 确保2D视图等比例
        
        # 当前视图模式
        self.current_view = '2d'
        
        # 初始化示例数据
        self._add_sample_data()
        
        # 绑定关闭窗口事件
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
    
    def _on_canvas_resize(self, event):
        """当画布大小变化时调整滚动框架宽度"""
        # 设置滚动框架宽度等于画布可见宽度
        self.canvas.itemconfig("all", width=event.width)
        self.scrollable_frame.config(width=event.width)

    def _on_mousewheel(self, event):
        """处理鼠标滚轮事件"""
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

    def _setup_geo_ops_tab(self):
        """设置几何操作选项卡（自适应宽度版）"""
        # 添加点区域
        point_frame = ttk.LabelFrame(self.geo_ops_tab, text="添加新点", padding=10)
        point_frame.pack(fill=tk.X, pady=5, expand=True)
        
        # 配置网格权重（让第二列可以扩展）
        point_frame.columnconfigure(1, weight=1)
        
        # 点名称
        ttk.Label(point_frame, text="点名称:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.point_name = tk.StringVar()
        entry = ttk.Entry(point_frame, textvariable=self.point_name)
        entry.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # X坐标
        ttk.Label(point_frame, text="X坐标:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.point_x = tk.StringVar()
        entry = ttk.Entry(point_frame, textvariable=self.point_x)
        entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # Y坐标
        ttk.Label(point_frame, text="Y坐标:").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.point_y = tk.StringVar()
        entry = ttk.Entry(point_frame, textvariable=self.point_y)
        entry.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        
        # Z坐标
        ttk.Label(point_frame, text="Z坐标:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.point_z = tk.StringVar(value="0")
        entry = ttk.Entry(point_frame, textvariable=self.point_z)
        entry.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        # 添加点按钮（水平填充）
        btn = ttk.Button(point_frame, text="添加点", command=self.add_point)
        btn.grid(row=4, column=0, columnspan=2, sticky="ew", pady=10, padx=5)
        
        # 添加线段区域
        segment_frame = ttk.LabelFrame(self.geo_ops_tab, text="添加线段", padding=10)
        segment_frame.pack(fill=tk.X, pady=5, expand=True)
        segment_frame.columnconfigure(1, weight=1)
        
        # 起点选择
        ttk.Label(segment_frame, text="起点:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.start_point = tk.StringVar()
        self.start_combo = ttk.Combobox(segment_frame, textvariable=self.start_point, state="readonly")
        self.start_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # 终点选择
        ttk.Label(segment_frame, text="终点:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.end_point = tk.StringVar()
        self.end_combo = ttk.Combobox(segment_frame, textvariable=self.end_point, state="readonly")
        self.end_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # 线段颜色选择
        ttk.Label(segment_frame, text="颜色:").grid(row=2, column=0, sticky=tk.W, pady=5)
        color_frame = ttk.Frame(segment_frame)
        color_frame.grid(row=2, column=1, sticky="ew", pady=5)
        
        # 颜色预览框
        self.color_preview = tk.Canvas(color_frame, width=20, height=20, bg=self.segment_color)
        self.color_preview.pack(side=tk.LEFT, padx=(0, 5))
        
        # 颜色选择按钮（水平填充）
        btn = ttk.Button(color_frame, text="选择颜色", command=self.choose_segment_color)
        btn.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        # 线段样式选择
        ttk.Label(segment_frame, text="线型:").grid(row=3, column=0, sticky=tk.W, pady=5)
        self.linestyle_var = tk.StringVar(value='solid')
        linestyle_combo = ttk.Combobox(segment_frame, textvariable=self.linestyle_var, 
                                      state="readonly", values=['solid', 'dashed', 'dotted', 'dashdot'])
        linestyle_combo.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        
        # 添加线段按钮（水平填充）
        btn = ttk.Button(segment_frame, text="添加线段", command=self.add_segment)
        btn.grid(row=4, column=0, columnspan=2, sticky="ew", pady=10, padx=5)
        
        # 示例区域
        sample_frame = ttk.LabelFrame(self.geo_ops_tab, text="示例操作", padding=10)
        sample_frame.pack(fill=tk.X, pady=5, expand=True)
        
        # 示例按钮（水平填充）
        btn = tk.Button(sample_frame, text="加载示例数据", command=self._add_sample_data)
        btn.pack(fill=tk.X, pady=5)
        
        # 删除操作区域
        delete_frame = ttk.LabelFrame(self.geo_ops_tab, text="删除操作", padding=10)
        delete_frame.pack(fill=tk.X, pady=5, expand=True)
        delete_frame.columnconfigure(1, weight=1)
        
        # 删除类型选择
        ttk.Label(delete_frame, text="删除类型:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.delete_type = tk.StringVar(value="点")
        delete_type_combo = ttk.Combobox(delete_frame, textvariable=self.delete_type, 
                                        state="readonly", values=['点', '线段'])
        delete_type_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        
        # 删除对象选择
        ttk.Label(delete_frame, text="选择对象:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.delete_object = tk.StringVar()
        self.delete_combo = ttk.Combobox(delete_frame, textvariable=self.delete_object, 
                                        state="readonly")
        self.delete_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        
        # 删除按钮（水平填充）
        btn = ttk.Button(delete_frame, text="删除", command=self.delete_object_action)
        btn.grid(row=2, column=0, columnspan=2, sticky="ew", pady=10, padx=5)
        
        # 绑定点添加事件更新下拉框
        self.point_name.trace_add("write", lambda *args: self._update_combo_boxes())
        self.delete_type.trace_add("write", lambda *args: self._update_delete_combo())

    def _setup_analysis_tab(self):
        """设置分析选项卡"""
        # 创建分析结果区域
        result_frame = ttk.Frame(self.analysis_tab)
        result_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # 添加分析按钮
        analyze_btn = ttk.Button(result_frame, text="运行几何分析", 
                               command=self.analyze_geometry)
        analyze_btn.pack(fill=tk.X, pady=(0, 15))
        
        # 结果显示（带滚动条）
        ttk.Label(result_frame, text="几何关系分析结果:").pack(anchor=tk.W, pady=(0, 5))
        
        # 创建带边框的结果文本框
        self.result_text = scrolledtext.ScrolledText(result_frame, 
                                                   bg="white", 
                                                   fg="black",
                                                   insertbackground="black",
                                                   font=("Consolas", 9),
                                                   height=15)
        self.result_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # 添加初始提示
        self.result_text.insert(tk.END, "点击上方按钮分析几何关系...\n")
        self.result_text.insert(tk.END, "结果将显示在此区域\n")
        self.result_text.config(state=tk.DISABLED)

    def _setup_status_tab(self):
        """设置状态选项卡"""
        # 创建选项卡框架
        status_frame = ttk.Frame(self.status_tab)
        status_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # 状态显示
        self.status_text = scrolledtext.ScrolledText(status_frame, 
                                                    bg="white", 
                                                    fg="black",
                                                    insertbackground="black",
                                                    font=("Consolas", 9),
                                                    height=15)
        self.status_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # 添加初始说明
        self.status_text.insert(tk.END, "状态信息将显示在此\n")
        self.status_text.config(state=tk.DISABLED)

    def choose_segment_color(self):
        """打开颜色选择对话框"""
        color = colorchooser.askcolor(title="选择线段颜色", initialcolor=self.segment_color)
        if color[1]:  # 用户选择了颜色
            self.segment_color = color[1]
            self.color_preview.config(bg=self.segment_color)

    def _update_combo_boxes(self):
        """更新所有下拉框"""
        points = list(self.analyzer.points.keys())
        segments = list(self.analyzer.segments.keys())
        
        self.start_combo['values'] = points
        self.end_combo['values'] = points
        
        if points:
            if not self.start_combo.get():
                self.start_combo.current(0)
            if not self.end_combo.get():
                self.end_combo.current(0)
        
        # 更新删除下拉框
        self._update_delete_combo()

    def _update_delete_combo(self):
        """更新删除下拉框内容"""
        delete_type = self.delete_type.get()
        
        if delete_type == "点":
            values = list(self.analyzer.points.keys())
        else:  # 线段
            values = list(self.analyzer.segments.keys())
        
        self.delete_combo['values'] = values
        
        if values:
            self.delete_combo.current(0)
        else:
            self.delete_object.set("")

    def _update_status(self):
        """更新状态信息"""
        status = self.analyzer.get_status()
        
        self.status_text.config(state=tk.NORMAL)
        self.status_text.delete(1.0, tk.END)
        
        # 更新点数量显示
        self.notebook.tab(2, text=f"状态信息 ({status['points_count']}点 {status['segments_count']}线段)")
        
        self.status_text.insert(tk.END, f"点数量: {status['points_count']}  线段数量: {status['segments_count']}\n\n")
        
        if status['point_details']:
            self.status_text.insert(tk.END, "点坐标列表:\n")
            for detail in status['point_details']:
                self.status_text.insert(tk.END, f"  • {detail}\n")
            self.status_text.insert(tk.END, "\n")
        
        if status['segment_details']:
            self.status_text.insert(tk.END, "线段信息:\n")
            for detail in status['segment_details']:
                self.status_text.insert(tk.END, f"  • {detail}\n")
        
        self.status_text.config(state=tk.DISABLED)

    def _add_sample_data(self):
        """添加示例数据（修正后）"""
        # 清空旧数据
        self.analyzer.points.clear()
        self.analyzer.segments.clear()
        
        # 添加基础点（包含Z轴方向）
        self.analyzer.add_point("O", 0, 0, 0)    # 原点
        self.analyzer.add_point("A", 3, 0, 0)     # X轴方向
        self.analyzer.add_point("B", 0, 3, 0)     # Y轴方向
        self.analyzer.add_point("C", 0, 0, 3)     # Z轴方向
        self.analyzer.add_point("D", 2, 2, 2)     # 空间点
        
        # 添加线段（使用正确的点命名）
        self.analyzer.add_segment("O", "A", '#FF0000', 'solid')   # 红色实线
        self.analyzer.add_segment("O", "B", '#00FF00', 'solid')   # 绿色实线
        self.analyzer.add_segment("O", "C", '#0000FF', 'solid')   # 蓝色实线
        self.analyzer.add_segment("O", "D", '#FF00FF', 'dashed') # 紫色虚线
        
        # 更新界面
        self._update_combo_boxes()
        self._update_status()
        self._redraw_plot()
        
        messagebox.showinfo("成功", "示例数据已加载")

    def add_point(self):
        """添加点操作（修正后）"""
        name = self.point_name.get().strip()
        x = self.point_x.get().strip()
        y = self.point_y.get().strip()
        z = self.point_z.get().strip()
        
        if not name or not x or not y:
            messagebox.showerror("错误", "点名称、X坐标和Y坐标不能为空")
            return
        
        # 尝试计算坐标值
        try:
            x_val = float(sp.sympify(x).evalf())
            y_val = float(sp.sympify(y).evalf())
            z_val = float(sp.sympify(z).evalf()) if z else 0.0
        except Exception as e:
            messagebox.showerror("错误", f"坐标格式无效: {str(e)}")
            return
        
        success, msg = self.analyzer.add_point(name, x_val, y_val, z_val)
        if not success:
            messagebox.showerror("错误", msg)
        else:
            messagebox.showinfo("成功", msg)
        
        # 清空输入
        self.point_name.set("")
        self.point_x.set("")
        self.point_y.set("")
        self.point_z.set("0")
        
        # 更新界面
        self._update_combo_boxes()
        self._update_status()
        self._redraw_plot()

    def add_segment(self):
        """添加线段操作（修正后）"""
        start = self.start_point.get()
        end = self.end_point.get()
        color = self.segment_color
        linestyle = self.linestyle_var.get()
        
        if not start or not end:
            messagebox.showerror("错误", "请选择起点和终点")
            return
        
        success, msg = self.analyzer.add_segment(start, end, color, linestyle)
        if not success:
            messagebox.showerror("错误", msg)
        else:
            messagebox.showinfo("成功", msg)
        
        # 更新界面
        self._update_combo_boxes()
        self._update_status()
        self._redraw_plot()

    def analyze_geometry(self):
        """分析几何关系（修正后）"""
        relations = self.analyzer.analyze_relations()
        
        self.result_text.config(state=tk.NORMAL)
        self.result_text.delete(1.0, tk.END)
        
        # 设置标题
        self.result_text.tag_configure("title", font=("Helvetica", 12, "bold"))
        self.result_text.tag_configure("normal", font=("Helvetica", 10))
        
        self.result_text.insert(tk.END, "几何关系分析结果\n", "title")
        self.result_text.insert(tk.END, "="*40 + "\n\n", "normal")
        
        # 垂直关系
        if relations['perpendicular']:
            self.result_text.insert(tk.END, "\n垂直关系:\n", "normal")
            for seg1, seg2 in relations['perpendicular']:
                self.result_text.insert(tk.END, f"  • {seg1} ⊥ {seg2}\n", "normal")
        
        # 平行关系
        if relations['parallel']:
            self.result_text.insert(tk.END, "\n平行关系:\n", "normal")
            for seg1, seg2 in relations['parallel']:
                self.result_text.insert(tk.END, f"  • {seg1} ∥ {seg2}\n", "normal")
        
        # 长度比关系
        if relations['length_ratio']:
            self.result_text.insert(tk.END, "\n长度比例关系:\n", "normal")
            for seg1, seg2, ratio in relations['length_ratio']:
                self.result_text.insert(tk.END, f"  • {seg1} : {seg2} = {ratio}:1\n", "normal")
        
        # 长度相等关系
        if relations['length_equal']:
            self.result_text.insert(tk.END, "\n相等长度:\n", "normal")
            for seg1, seg2 in relations['length_equal']:
                self.result_text.insert(tk.END, f"  • |{seg1}| = |{seg2}|\n", "normal")
        
        # 长度差关系
        if relations['length_diff']:
            self.result_text.insert(tk.END, "\n长度差值:\n", "normal")
            for seg1, seg2, diff in relations['length_diff']:
                self.result_text.insert(tk.END, f"  • |{seg1}| - |{seg2}| = {diff}\n", "normal")
        
        if not any(relations.values()):
            self.result_text.insert(tk.END, "\n未检测到显著的几何关系", "normal")
        
        self.result_text.config(state=tk.DISABLED)

    def delete_object_action(self):
        """删除点或线段（合并操作）"""
        delete_type = self.delete_type.get()
        obj_name = self.delete_object.get()
        
        if not obj_name:
            messagebox.showerror("错误", "请选择要删除的对象")
            return
        
        if delete_type == "点":
            self.delete_point(obj_name)
        else:
            self.delete_segment(obj_name)

    def delete_point(self, point_name):
        """删除点（修正后）"""
        # 检查是否存在依赖该点的线段
        dependent_segments = [
            seg_name for seg_name, (start, end, color, linestyle) in self.analyzer.segments.items()
            if start == point_name or end == point_name
        ]
        
        if dependent_segments:
            confirm = messagebox.askyesno("确认删除", 
                                       f"点 '{point_name}' 被 {len(dependent_segments)} 条线段引用\n"
                                       "删除点将同时删除这些线段，是否继续？")
            if not confirm:
                return
            
            # 删除依赖的线段
            for seg_name in dependent_segments:
                del self.analyzer.segments[seg_name]
        
        # 删除点
        if point_name in self.analyzer.points:
            del self.analyzer.points[point_name]
        else:
            messagebox.showerror("错误", f"点 '{point_name}' 不存在")
            return
        
        # 更新界面
        self._update_combo_boxes()
        self._update_status()
        self._redraw_plot()
        
        messagebox.showinfo("成功", f"点 '{point_name}' 已删除")

    def delete_segment(self, seg_name):
        """删除线段（修正后）"""
        # 确认删除
        confirm = messagebox.askyesno("确认删除", f"确定删除线段 '{seg_name}' 吗？")
        if not confirm:
            return
        
        # 删除线段
        if seg_name in self.analyzer.segments:
            del self.analyzer.segments[seg_name]
        else:
            messagebox.showerror("错误", "线段不存在")
            return
            
        # 更新界面
        self._update_combo_boxes()
        self._update_status()
        self._redraw_plot()
        
        messagebox.showinfo("成功", f"线段 '{seg_name}' 已删除")

    def toggle_3d_view(self):
        """切换3D/2D视图（修正后）"""
        # 清除当前画布并重新创建子图
        self.fig.clf()
        
        # 创建新视图
        if self.current_view == '2d':
            # 切换到3D
            self.current_view = '3d'
            self.ax = self.fig.add_subplot(111, projection='3d')
            self.ax.set_facecolor("white")  # 白色背景
            self.ax.set_title("3D几何视图", color="black")
            self.ax.tick_params(colors='black')
            self.ax.xaxis.label.set_color('black')
            self.ax.yaxis.label.set_color('black')
            self.ax.zaxis.label.set_color('black')
            self.btn_switch_3d.config(text="切换到2D视图")
        else:
            # 切换回2D
            self.current_view = '2d'
            self.ax = self.fig.add_subplot(111)
            self.ax.set_facecolor("white")  # 白色背景
            self.ax.set_title("2D几何视图", color="black")
            self.ax.tick_params(colors='black')
            self.btn_switch_3d.config(text="切换到3D视图")
        
        # 重绘图形
        self._redraw_plot()

    def _draw_2d(self):
        """绘制2D视图（确保等比例）"""
        self.ax.clear()
        self.ax.set_facecolor("white")  # 白色背景
        self.ax.grid(True, linestyle='--', alpha=0.7)
        self.ax.set_title("2D几何视图", color="black")
        self.ax.tick_params(colors='black')
        self.ax.set_aspect('equal')  # 确保XY等比例
        
        # 获取所有点坐标以确定范围
        all_points = list(self.analyzer.points.values())
        if all_points:
            xs, ys, zs = zip(*all_points)
            min_x, max_x = min(xs), max(xs)
            min_y, max_y = min(ys), max(ys)
            
            # 计算范围并添加10%的边距
            range_x = max_x - min_x
            range_y = max_y - min_y
            max_range = max(range_x, range_y) or 1
            margin = max_range * 0.1
            
            self.ax.set_xlim(min_x - margin, max_x + margin)
            self.ax.set_ylim(min_y - margin, max_y + margin)
        
        # 绘制所有点
        for name, (x, y, z) in self.analyzer.points.items():
            self.ax.plot(x, y, 'bo', markersize=8)
            self.ax.text(x + 0.1, y + 0.1, name, fontsize=10, color='black')
        
        # 绘制所有线段（使用自定义颜色和线型）
        for seg_name, (start, end, color, linestyle) in self.analyzer.segments.items():
            s_x, s_y, s_z = self.analyzer.points[start]
            e_x, e_y, e_z = self.analyzer.points[end]
            
            # 使用自定义颜色和线型
            self.ax.plot([s_x, e_x], [s_y, e_y], 
                         color=color, linestyle=linestyle, linewidth=1.5)
            
            # 在线段中间显示线段名
            mid_x = (s_x + e_x) / 2
            mid_y = (s_y + e_y) / 2
            self.ax.text(mid_x, mid_y, seg_name, fontsize=9, 
                         bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=2), 
                         color='black')
        
        # 重新绘制
        self.canvas_plot.draw()

    def _draw_3d(self):
        """绘制3D视图（确保等比例）"""
        self.ax.clear()
        self.ax.set_facecolor("white")  # 白色背景
        self.ax.grid(True, linestyle='--', alpha=0.3)
        self.ax.set_title("3D几何视图", color="black")
        
        # 设置坐标轴标签
        self.ax.set_xlabel('X', color='black')
        self.ax.set_ylabel('Y', color='black')
        self.ax.set_zlabel('Z', color='black')
        self.ax.tick_params(colors='black')
        
        # 获取所有点坐标以确定范围
        all_points = list(self.analyzer.points.values())
        if all_points:
            xs, ys, zs = zip(*all_points)
            min_x, max_x = min(xs), max(xs)
            min_y, max_y = min(ys), max(ys)
            min_z, max_z = min(zs), max(zs)
            
            # 计算范围并添加10%的边距
            range_x = max_x - min_x
            range_y = max_y - min_y
            range_z = max_z - min_z
            max_range = max(range_x, range_y, range_z) or 1
            margin = max_range * 0.1
            
            # 计算中心点
            center_x = (min_x + max_x) / 2
            center_y = (min_y + max_y) / 2
            center_z = (min_z + max_z) / 2
            
            # 设置坐标轴范围（确保等比例）
            self.ax.set_xlim(center_x - max_range/2 - margin, center_x + max_range/2 + margin)
            self.ax.set_ylim(center_y - max_range/2 - margin, center_y + max_range/2 + margin)
            self.ax.set_zlim(center_z - max_range/2 - margin, center_z + max_range/2 + margin)
        
        # 绘制所有点
        for name, (x, y, z) in self.analyzer.points.items():
            self.ax.scatter(x, y, z, color='b', s=50)
            self.ax.text(x, y, z + 0.1, name, fontsize=10, color='black')
        
        # 绘制所有线段（使用自定义颜色和线型）
        for seg_name, (start, end, color, linestyle) in self.analyzer.segments.items():
            s_x, s_y, s_z = self.analyzer.points[start]
            e_x, e_y, e_z = self.analyzer.points[end]
            
            # 使用自定义颜色和线型
            self.ax.plot([s_x, e_x], [s_y, e_y], [s_z, e_z], 
                         color=color, linestyle=linestyle, linewidth=1.5)
            
            # 在线段中间显示线段名
            mid_x = (s_x + e_x) / 2
            mid_y = (s_y + e_y) / 2
            mid_z = (s_z + e_z) / 2
            self.ax.text(mid_x, mid_y, mid_z, seg_name, fontsize=9, 
                        bbox=dict(facecolor='white', alpha=0.8, edgecolor='none', pad=2), 
                        color='black')
        
        # 设置3D视角
        self.ax.view_init(elev=30, azim=45)
        
        # 确保XYZ等比例
        self.ax.set_box_aspect([1, 1, 1])  # 正方体比例
        
        # 重新绘制
        self.canvas_plot.draw()

    def _redraw_plot(self):
        """重绘当前视图（统一入口）"""
        if self.current_view == '2d':
            self._draw_2d()
        else:
            self._draw_3d()
        
        # 强制更新画布
        self.canvas_plot.draw_idle()

    def on_close(self):
        """窗口关闭时清理资源"""
        plt.close('all')
        self.root.destroy()

if __name__ == "__main__":
    # 配置matplotlib
    rcParams['font.sans-serif'] = ['Microsoft YaHei', 'Arial Unicode MS', 'sans-serif']
    rcParams['axes.unicode_minus'] = False
    
    root = tk.Tk()
    app = GeometryGUI(root)
    root.mainloop()
